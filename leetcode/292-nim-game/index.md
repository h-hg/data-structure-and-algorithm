# Nim Game

- [Leetcode](https://leetcode.com/problems/nim-game)
- [力扣中国](https://leetcode.cn/problems/nim-game)

## Problem

[](desc.md ':include')

## Solution

### Dynamic Programming

符合程序员的思路，大概就是动态规划。

若用 `dp[i]` 表示石头数量在 `i` 的情况下，我是否能赢。
那么 `dp[i] = dp[i-1] == false || dp[i-2] == false || dp[i-3] == false`（ `dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3]`），即判断我拿走一块（`dp[i-1]`）、两块（`dp[i-2]`）以及是三块（`dp[i-3]`）这三种情形下对方是否存在存在输的情形，来得知我是否能赢。

自顶而下，结合 DFS 执行 DP，代码如下

[](dp-dfs.cpp ':include :type=code cpp')

结果超过内存限制。

如果考虑自底而上的 DP，则 `dp` 只需要两个状态，内存还可以再减少一些。

由于 `vector<bool>` 有进行特化，一个元素只占了一个 bit，结果并没有超过内存限制，但是仍然超时。
这证明 $\Theta(n)$ 的算法不可行。

上面思路，其实还可以进一步压缩 `dp` 数组的长度。

从递推式子 `dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3]` 可以知道，`dp[i]` 的计算只依赖前三个，可将 `dp` 压缩为长度为 $3$。

[](dp-len-3.cpp ':include :type=code cpp')

### Game Theory

其实题目假设两个人足够聪明，也暗示了结果由输入唯一确定。

让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜；如果堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，他可以将剩余的石头全部取完，从而他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 $4$ 的情况。

- 我们继续推理，假设当前堆里只剩下五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。显然我们继续推理，可以看到它会以相同的模式不断重复 $n = 4, 8, 12, 16, \dots$，基本可以看出如果堆里的石头数目为 $4$ 的倍数时，你一定会输掉游戏。

- 如果总的石头数目为 $4$ 的倍数时，因为无论你取多少石头，对方总有对应的取法，让剩余的石头的数目继续为 $4$ 的倍数。对于你或者你的对手取石头时，显然最优的选择是当前己方取完石头后，让剩余的石头的数目为 $4$ 的倍数。假设当前的石头数目为 $x$，如果 $x$ 为 $4$ 的倍数时，则此时你必然会输掉游戏；如果 $x$ 不为 $4$ 的倍数时，则此时你只需要取走 $x \% 4$ 个石头时，则剩余的石头数目必然为 $4$ 的倍数，从而对手会输掉游戏。

[](solution.cpp ':include :type=code cpp')
